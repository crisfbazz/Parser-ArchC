/******************************************************
* Instruction Set Architecture header file.          *
* This file is automatically generated by ArchC      *
* WITHOUT WARRANTY OF ANY KIND, either express       *
* or implied.                                        *
* For more information on ArchC, please visit:       *
* http://www.archc.org                               *
*                                                    *
* The ArchC Team                                     *
* Computer Systems Laboratory (LSC)                  *
* IC-UNICAMP                                         *
* http://www.lsc.ic.unicamp.br                       *
******************************************************/

\#ifndef _$(upper_project_name)_ISA_H
\#define _$(upper_project_name)_ISA_H

\#include "$(project_name)_parms.H"
\#include "ac_instr.H"
\#include "ac_decoder_rt.H"
\#include "ac_instr_info.H"
\#include "$(project_name)_arch.H"
\#include "$(project_name)_arch_ref.H"
#if ($ACABIFlag)
\#include "$(project_name)_syscall.H"
#end if
#if ($ACStatsFlag)
\#include "$(project_name)_stats.H"
#end if

namespace $(project_name)_parms {

  class $(project_name)_isa: public $(project_name)_arch_ref#slurp
#if ($ACStatsFlag)
, public $(project_name)_all_stats#slurp
#end if
 {

    private:
      typedef ac_instr<AC_DEC_FIELD_NUMBER> ac_instr_t;
      #for pgroup in $group_list
      static bool group_$(pgroup['name'])[AC_DEC_INSTR_NUMBER];
      #end for

    public:
      static ac_dec_field fields[AC_DEC_FIELD_NUMBER];
      static ac_dec_format formats[AC_DEC_FORMAT_NUMBER];
      static ac_dec_list dec_list[AC_DEC_LIST_NUMBER];
      static ac_dec_instr instructions[AC_DEC_INSTR_NUMBER];
      static const ac_instr_info instr_table[AC_DEC_INSTR_NUMBER + 1];
      static const unsigned instr_format_table[AC_DEC_INSTR_NUMBER + 1];

      ac_decoder_full* decoder;
      #if ($ACABIFlag)

      $(project_name)_syscall syscall;
      #end if

      #* current instruction ID *#
      int cur_instr_id;

      #* ac_helper *#
      #if ($helper_contents)
      $helper_contents

      #end if
      ## Emitting Constructor
      //!Constructor
      $(project_name)_isa($(project_name)_arch& ref) : $(project_name)_arch_ref(ref)#slurp
      #if ($ACABIFlag)
, syscall(ref)#slurp
      #end if
 {
        //!Building Decoder.
        decoder = ac_decoder_full::CreateDecoder($(project_name)_isa::formats, $(project_name)_isa::instructions, &ref);
        #* Closing Constructor declaration *#
      }

      #if ($ACCurInstrID)
      #* Getter methods for current instruction *#
      inline const char* get_name() {
          return instr_table[cur_instr_id].ac_instr_name;
      }
      inline const char* get_mnemonic() {
          return instr_table[cur_instr_id].ac_instr_mnemonic;
      }
      inline unsigned get_size() {
          return instr_table[cur_instr_id].ac_instr_size;
      };
      inline unsigned get_cycles() {
          return instr_table[cur_instr_id].ac_instr_cycles;
      };
      inline unsigned get_min_latency() {
          return instr_table[cur_instr_id].ac_instr_min_latency;
      };
      inline unsigned get_max_latency() {
          return instr_table[cur_instr_id].ac_instr_max_latency;
      };

      ## Group query methods.
      #for pgroup in $group_list
      inline const bool belongs_to_$(pgroup['name'])() {
          return group_$(pgroup['name'])[cur_instr_id];
      }
      #end for
      #end if

      ##Turn-on or off Forced Inline in Interpretation Routines
      #set $finline = ""
      #if ($ACForcedInline)
      #set $finline = "inline __attribute__((always_inline)) "

      #end if
      #* Instruction Behavior Method declarations *#
      #* instruction *#
      $(finline)void _behavior_instruction(#slurp
      #* common_instr_field_list has the list of fields for the generic instruction. *#
      #for pfield in $common_instr_field_list
      #if not ($pfield['sign'])
u#slurp
      #end if
      #if ($pfield['size'] < 9)
int8_t#slurp
      #else if ($pfield['size'] < 17)
int16_t#slurp
      #else if ($pfield['size'] < 33)
int32_t#slurp
      #else
int64_t#slurp
      #end if
 $pfield['name']#slurp
      #if ( $pfield != $common_instr_field_list[-1] )
, #slurp
      #end if
      #end for
);

      #* begin & end *#
      $(finline)void _behavior_begin();
      $(finline)void _behavior_end();

      #* types/formats *#
      #for pformat in $format_ins_list
      $(finline)void _behavior_$(project_name)_$(pformat['name'])(#slurp
      #for pfield in pformat['fields']
      #if not ($pfield['sign'])
u#slurp
      #end if
      #if ($pfield['size'] < 9)
int8_t#slurp
      #else if ($pfield['size'] < 17)
int16_t#slurp
      #else if ($pfield['size'] < 33)
int32_t#slurp
      #else
int64_t#slurp
      #end if
 $pfield['name']#slurp
      #if ($pfield != $pformat['fields'][-1])
, #slurp
      #end if
      #end for
);
      #end for

      #* instructions *#
      #for pinstr in $instr_list
      #for pformat in $format_ins_list
      #if ($pinstr['format'] == $pformat['name'])
      $(finline)void behavior_$(pinstr['name'])(#slurp
      #break
      #end if
      #end for
      #for pfield in $pformat['fields']
      #if not ($pfield['sign'])
u#slurp
      #end if
      #if ($pfield['size'] < 9)
int8_t#slurp
      #else if ($pfield['size'] < 17)
int16_t#slurp
      #else if ($pfield['size'] < 33)
int32_t#slurp
      #else
int64_t#slurp
      #end if
 $pfield['name']#slurp
      #if ($pfield != $pformat['fields'][-1])
, #slurp
      #end if
      #end for
);
      #end for

  #* Closing class declaration. *#
  };
    #* Closing namespace declaration. *#
};

#* END OF FILE *#
\#endif //_$(upper_project_name)_ISA_H



