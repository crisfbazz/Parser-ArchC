/******************************************************
* Processor Module Implementation File.              *
* This file is automatically generated by ArchC      *
* WITHOUT WARRANTY OF ANY KIND, either express       *
* or implied.                                        *
* For more information on ArchC, please visit:       *
* http://www.archc.org                               *
*                                                    *
* The ArchC Team                                     *
* Computer Systems Laboratory (LSC)                  *
* IC-UNICAMP                                         *
* http://www.lsc.ic.unicamp.br                       *
******************************************************/

\#include  "$(project_name).H"
\#include  "$(project_name)_isa.cpp"

#if ($ACABIFlag)
\#include  "$(project_name)_syscall.H"

#end if
#if ($ACThreading)
#****************************************************#
#* START EmitDispatch                               *#
#*!  Emits the Dispatch Function used by Threading  *#
#* \brief Used by CreateProcessorImpl function      *#
#****************************************************#
void* $(project_name)::dispatch() {
  ##!Emit update method.
  #******************************************#
  #* START EmitUpdateMethod                 *#
  #*!  Emits a method to update pipe regs   *#
  #* \brief Used by CreateArchImpl function *#
  #******************************************#
  ##Emiting Update Method.
  #if ($ACDelayFlag or $HaveMemHier or $ACWaitFlag)
  //!Updating Regs for behavioral simulation.
  #end if
  #if not ($ACLongJmpStop)
  if (ac_stop_flag)
  #if ($ACThreading)
    longjmp(ac_env, AC_ACTION_STOP);
  #else
    return;
  #end if

  #end if
  #if ($ACDelayFlag)
  if (!ac_wait_sig) {
    #for pstorage in $storage_list
    $(pstorage['name']).commit_delays((double)ac_cycle_counter);
    #end for
    ac_pc.commit_delays((double)ac_cycle_counter);
    if (!ac_parallel_sig)
        ac_cycle_counter ++;
    else
        ac_parallel_sig = 0;
  }

  #end if
  #*
  #if ($HaveMemHier)
  #for pstorage in $storage_list
  #if ($pstorage['type'] == "CACHE" or $pstorage['type'] == "ICACHE" or $pstorage['type'] == "DCACHE" or $pstorage['type'] == "MEM")
  $(pstorage['name']).process_request( );
  #end if
  #end for

  #end if *#
  #if ($ACWaitFlag)
  if (ac_qk.need_sync()) {
    ac_qk.sync();
  }

  #end if
  #** END EmitUpdateMethod **#
  #***************************************#
  #* START EmitFetchInit                 *#
  #*!  Emits the if statement executed   *#
  #*!  before fetches are performed.     *#
  #***************************************#
  #if ($ACPCAddress)
  #if not ($ACDecCacheFlag)
  if (ac_pc >= APP_MEM->get_size()) {
  #else
  if (ac_pc >= dec_cache_size) {
  #end if
    cerr << "ArchC: Address out of bounds (pc=0x" << hex << ac_pc << ")." << endl;
    stop();
    #if ($ACThreading)
    longjmp(ac_env, AC_ACTION_STOP);
    #else
    return;
    #end if
  }
  #end if

  #*** END EmitFetchInit ***#
  ac_instr_counter++;
  unsigned ins_id;
  #if ($ACABIFlag and not $ACDecCacheFlag)
  #if ($ACSyscallJump)
  bool exec = true;

  if (ac_pc < 0x100) {
  #end if
    ##Emiting system calls handler.
    //!Handling System calls.
    switch (ac_pc) {
      \#define AC_SYSC(NAME,LOCATION)  \
      case LOCATION:  \
        #if ($ACStatsFlag)
        ISA.stats[$(project_name)_stat_ids::SYSCALLS]++;  \
        #end if
        #if ($ACDebugFlag)
        if (ac_do_trace != 0)  \
          trace_file << hex << ac_pc << dec << endl;  \
        #end if
        ISA.syscall.NAME();  \
        #if ($ACSyscallJump)
        exec = false;  \
        #end if
        #if ($ACThreading)
        return IntRoutine[0];  \
        #end if
        break;
      \#include <ac_syscall.def>
      \#undef AC_SYSC

      #if ($ACSyscallJump)
    } // switch(ac_pc)
  } // if(ac_pc < 0x100)
  if (exec) {
      #else
      default:
      #end if
  #end if
        #if ($ACFullDecode)
        instr_dec = (DEC_CACHE + (ac_pc#slurp
#if ($ACIndexFix)
/ $(largest_format_size/8)#slurp
#end if
));
        ins_id = instr_dec->id;

        #else
        #********************************************#
        #* START EmitDecodification                 *#
        #*!  Emits the if statement that handles instruction decodification *#
        #* \brief Used by EmitProcessorBhv, EmitMultCycleProcessorBhv and CreateStgImpl functions *#
        #********************************************#
        #* #if ($HaveMemHier)
        #if ($fetchsize == $wordsize)
        *((ac_fetch*)(fetch)) = IM->read(ac_pc);
        #else if ($fetchsize == $wordsize/2)
        *((ac_fetch*)(fetch)) = IM->read_half(ac_pc);
        #else if ($fetchsize == 8)
        *((ac_fetch*)(fetch)) = IM->read_byte(ac_pc);
        #else
        <% print "ArchC ERROR: Fetchsize differs from wordsize or (wordsize/2) or 8: not implemented." %>
        #stop
        #end if

        #end if
        if (ac_wait_sig) {
          #if ($ACThreading)
          longjmp(ac_env, AC_ACTION_STOP);
          #else
          return;
          #end if
        }

        *#
        #if ($ACDecCacheFlag)
        instr_dec = (DEC_CACHE + (#slurp
#if ($ACFullDecode)
decode_pc#slurp
#else
ac_pc#slurp
#end if
#if ($ACIndexFix)
 / $(largest_format_size/8)#slurp
#end if
));
        #if not ($ACFullDecode)
        if (!instr_dec->valid) {
        #end if
          unsigned* ins_cache;
        #end if
          #if not ($ACFullDecode)
          decode_pc = ac_pc;
          #end if
          quant = 0;
          ins_cache = (ISA.decoder)->Decode(reinterpret_cast<unsigned char*>(buffer), quant);

          #if ($ACDecCacheFlag)
          #if ($ACFullDecode)
          if( ins_cache ) {
          #else
          instr_dec->valid = true;
          #end if
          instr_dec->id = ins_cache ? ins_cache[IDENT]: 0;
          #if ($ACThreading)
          instr_dec->end_rot = IntRoutine[instr_dec->id];
          #end if
          #**********************************************#
          #* START EmitDecCacheAt                       *#
          #*!  Emits a Decoder Cache Attribution.       *#
          #* \brief Used by EmitDecodification function *#
          #**********************************************#
          switch (ISA.instr_format_table[instr_dec->id]) {
            #for pformat in $format_ins_list
            case $pformat['id']:
              #for pfield in $pformat['fields']
              instr_dec->F_$pformat['name'].$pfield['name'] = ins_cache[$pfield['id']];
              #end for
              break;
            #end for
            #if not ($ACFullDecode)
            default:
              cerr << "ArchC Error: Unidentified instruction. " << endl;
              cerr << "PC = " << hex << ac_pc << dec << endl;
              stop();
              #if ($ACThreading)
              longjmp(ac_env, AC_ACTION_STOP);
              #else
              return;
              #end if
            #end if
          }

          #* END EmitDecCacheAt *#
        }

        #if not ($ACFullDecode)
        ins_id = instr_dec->id;
        #end if
        #else
        ins_id = ins_cache ? ins_cache[IDENT]: 0;

        ##Checking if it is a valid instruction
        if(ins_id == 0) {
          cerr << "ArchC Error: Unidentified instruction. " << endl;
          cerr << "PC = " << hex << ac_pc << dec << endl;
          stop();
          #if ($ACThreading)
          longjmp(ac_env, AC_ACTION_STOP);
          #else
          return;
          #end if
        }
        #end if
        #*** END EmitDecodification ***#
        #end if
        #**********************************************************#
        #* START EmitInstrExecIni                                 *#
        #*!  Emit initial code for executing instructions         *#
        #* \brief Used by EmitInstrExec and EmitDispatch functions*#
        #**********************************************************#
        #if ($ACGDBIntegrationFlag)
        if (gdbstub && gdbstub->stop(ac_pc)) gdbstub->process_bp();

        #end if
        #if ($ACCurInstrID)
        ISA.cur_instr_id = ins_id;
        #end if
        #if not ($ACThreading and $ACABIFlag)
        ISA._behavior_instruction(#slurp
        #* common_instr_field_list has the list of fields for the generic instruction. *#
        #if ($ACDecCacheFlag)
        #for pfield in $common_instr_field_list
        #set $pformat = $format_ins_list[0]
instr_dec->F_$pformat['name'].$pfield['name']#slurp
        #if ($pfield != $common_instr_field_list[-1])
, #slurp
        #end if
        #end for
        #else
        #for pfield in $common_instr_field_list
ins_cache[$pfield['id']]#slurp
        #if ($pfield != $common_instr_field_list[-1])
, #slurp
        #end if
        #end for
        #end if
);
        #end if

        #* END EmitInstrExecIni *#
        #if ($ACStatsFlag)
        if (!ac_wait_sig && ins_id) {
          ISA.stats[%s_stat_ids::INSTRUCTIONS]++;
          (*(ISA.instr_stats[ins_id]))[$(project_name)_instr_stat_ids::COUNT]++;
        }

        #end if
        #if ($ACDebugFlag)
        if (ac_do_trace != 0)
          trace_file << hex << ac_pc << dec <<"\n";

        #end if
        #if ($ACABIFlag and not $ACDecCacheFlag)
        #if ($ACSyscallJump)
  } // if (exec)
        #else
        break;
    } // switch (ac_pc)
        #end if

        #end if
    #if ($ACVerboseFlag)
    #if ($ACABIFlag)
    done.write(1);
    #else
    bhv_done.write(1);
    #end if

    #end if
    #if ($ACDecCacheFlag)
    return instr_dec->end_rot;
    #else
    return IntRoutine[ins_id];
    #end if
}

#* END EmitDispatch  *#
#end if
void $(project_name)::behavior() {

  #if ($ACDebugFlag)
  extern bool ac_do_trace;
  extern ofstream trace_file;

  #end if
  #if ($ACThreading)
  #**********************************************#
  #* START EmitVetLabelAt                       *#
  #*!  Emits the Vector with Address of the     *#
  #* Interpretation Routines used by Threading  *#
  #* \brief Used by CreateProcessorImpl function*#
  #**********************************************#
  #set $cont = 0
  #set $ident = "      "
  void* vet[] = {&&I_Init#slurp
  #for pinstr in $instr_list
, #slurp
  #if ($cont >= 4)

  $ident#slurp
  #set $cont = 0
  #end if
  #set $cont += 1
&&I_$pinstr['name']#slurp
  #end for
};
  IntRoutine = vet;

  #* END EmitVetLabelAt *#
  #else
  unsigned ins_id;

  #end if
  #* Delayed program loading *#
  if (has_delayed_load) {
      APP_MEM->load(delayed_load_program);
      ac_pc = ac_start_addr;
      has_delayed_load = false;
  }

  #*
  #if ($HaveMemHier)
  if (ac_wait_sig) {
      return;
  }

  #end if *#
  ## Starting
  if (start_up) {
    #if ($ACABIFlag)
    ISA.syscall.set_prog_args(argc, argv);
    #end if
    start_up = 0;
    #if ($ACDecCacheFlag)
    init_dec_cache();
    #end if
  }

  #if ($ACFullDecode)
  for (decode_pc = ac_pc; decode_pc < dec_cache_size; decode_pc += $(largest_format_size/8)) {
    #********************************************#
    #* START EmitDecodification                 *#
    #*!  Emits the if statement that handles instruction decodification *#
    #* \brief Used by EmitProcessorBhv, EmitMultCycleProcessorBhv and CreateStgImpl functions *#
    #********************************************#
    #* #if ($HaveMemHier)
    #if ($fetchsize == $wordsize)
    *((ac_fetch*)(fetch)) = IM->read(ac_pc);
    #else if ($fetchsize == $wordsize/2)
    *((ac_fetch*)(fetch)) = IM->read_half(ac_pc);
    #else if ($fetchsize == 8)
    *((ac_fetch*)(fetch)) = IM->read_byte(ac_pc);
    #else
    <% print "ArchC ERROR: Fetchsize differs from wordsize or (wordsize/2) or 8: not implemented." %>
    #stop
    #end if

    #end if
    if(ac_wait_sig) {
      #if ($ACThreading)
      longjmp(ac_env, AC_ACTION_STOP);
      #else
      return;
      #end if
    }
    *#

    #if ($ACDecCacheFlag)
    instr_dec = (DEC_CACHE + (#slurp
#if ($ACFullDecode)
decode_pc#slurp
#else
ac_pc#slurp
#end if
#if ($ACIndexFix)
/ $(largest_format_size/8)#slurp
#end if
));
    #if not ($ACFullDecode)
    if (!instr_dec->valid) {
    #end if
      unsigned* ins_cache;
    #end if
      #if not ($ACFullDecode)
      decode_pc = ac_pc;
      #end if
      quant = 0;
      ins_cache = (ISA.decoder)->Decode(reinterpret_cast<unsigned char*>(buffer), quant);

    #if ($ACDecCacheFlag)
    #if ($ACFullDecode)
    if( ins_cache ) {
    #else
    instr_dec->valid = true;
    #end if
      instr_dec->id = ins_cache ? ins_cache[IDENT]: 0;
      #if ($ACThreading)
      instr_dec->end_rot = IntRoutine[instr_dec->id];
      #end if
      #**********************************************#
      #* START EmitDecCacheAt                       *#
      #*!  Emits a Decoder Cache Attribution.       *#
      #* \brief Used by EmitDecodification function *#
      #**********************************************#
      switch (ISA.instr_format_table[instr_dec->id]) {
        #for pformat in $format_ins_list
        case $pformat['id']:
          #for pfield in $pformat['fields']
          instr_dec->F_$pformat['name'].$pformat['name'] = ins_cache[$pformat['id']];
          #end for
          break;
        #end for
        #if not ($ACFullDecode)
        default:
          cerr << "ArchC Error: Unidentified instruction. " << endl;
          cerr << "PC = " << hex << ac_pc << dec << endl;
          stop();
          #if ($ACThreading)
          longjmp(ac_env, AC_ACTION_STOP);
          #else
          return;
          #end if
        #end if
      }

      #* END EmitDecCacheAt *#
    }

    #if not ($ACFullDecode)
    ins_id = instr_dec->id;
    #end if
    #else
    ins_id = ins_cache ? ins_cache[IDENT]: 0;

    ##Checking if it is a valid instruction
    if (ins_id == 0) {
      cerr << "ArchC Error: Unidentified instruction. " << endl;
      cerr << "PC = " << hex << ac_pc << dec << endl;
      stop();
      #if ($ACThreading)
      longjmp(ac_env, AC_ACTION_STOP);
      #else
      return;
      #end if
    }
    #end if
    #*** END EmitDecodification ***#
  }

  #end if

  #if ($ACThreading and $ACABIFlag and $ACDecCacheFlag)
  \#define AC_SYSC(NAME,LOCATION) \
  instr_dec = (DEC_CACHE + (LOCATION#slurp
  #if ($ACIndexFix)
/ $(largest_format_size/8)#slurp
  #end if
)); \
  #if not ($ACFullDecode)
  instr_dec->valid = true; \
  #end if
  instr_dec->id = 0; \
  instr_dec->end_rot = &&Sys_\#\#LOCATION;

  \#include <ac_syscall.def>
  \#undef AC_SYSC

  #end if

  ##Longjmp of ac_annul_sig and ac_stop_flag
  int action = setjmp(ac_env);
  #if ($ACLongJmpStop or $ACThreading)
  if (action == AC_ACTION_STOP) return;

  #end if
  ##Emiting processor behavior method implementation.
  #if ($ACThreading)
  #******************************************#
  #* START EmitInstrExec                    *#
  #*!  Emit code for executing instructions *#
  #* \brief Used by EmitProcessorBhv, EmitMultCycleProcessorBhv and CreateStgImpl functions *#
  #******************************************#
  #if ($ACThreading)
  I_Init:
    goto *dispatch();

  #if ($ACABIFlag and $ACDecCacheFlag)
  \#define AC_SYSC(NAME,LOCATION) \
  Sys_\#\#LOCATION: \
    #if ($ACStatsFlag)
    ISA.stats[$(project_name)_stat_ids::SYSCALLS]++; \
    #end if
    #if ($ACDebugFlag)
    if (ac_do_trace != 0)
      trace_file << hex << ac_pc << dec << endl; \
    #end if
    ISA.syscall.NAME(); \
    goto *dispatch();

  \#include <ac_syscall.def>
  \#undef AC_SYSC

  #end if
  #else
  #**********************************************************#
  #* START EmitInstrExecIni                                 *#
  #*!  Emit initial code for executing instructions         *#
  #* \brief Used by EmitInstrExec and EmitDispatch functions*#
  #**********************************************************#
  #if ($ACGDBIntegrationFlag)
  if (gdbstub && gdbstub->stop(ac_pc)) gdbstub->process_bp();

  #end if
  #if ($ACCurInstrID)
  ISA.cur_instr_id = ins_id;
  #end if
  #if not ($ACThreading and $ACABIFlag)
  ISA._behavior_instruction(#slurp
  #* common_instr_field_list has the list of fields for the generic instruction. *#
  #if ($ACDecCacheFlag)
  #for pfield in $common_instr_field_list
  #set $pformat = $format_ins_list[0]
instr_dec->F_$(pformat['name']).$(pfield['name'])#slurp
  #if ($pfield != $common_instr_field_list[-1])
, #slurp
  #end if
  #end for
  #else
  #for pfield in $common_instr_field_list
ins_cache[$(pfield['id'])]#slurp
  #if ($pfield != $common_instr_field_list[-1])
, #slurp
  #end if
  #end for
  #end if
);
  #end if

  #* END EmitInstrExecIni *#
  #* Switch statement for instruction selection *#
  switch (ins_id) {
  #end if
    #for pinstr in $instr_list
    #if ($ACThreading)
    I_$(pinstr['name']): // Instruction $(pinstr['name'])
      #if ($ACABIFlag)
      ISA._behavior_instruction(#slurp
      #* common_instr_field_list has the list of fields for the generic instruction. *#
      #if ($ACDecCacheFlag)
      #for pformat in $format_ins_list
      #if ($pinstr['format'] == $pformat['name'])
      #for pfield in $common_instr_field_list
instr_dec->F_$(pformat['name']).$(pfield['name'])#slurp
      #if ($pfield != $common_instr_field_list[-1])
, #slurp
      #end if
      #end for
      #break
      #end if
      #end for
      #else
      #for pfield in $common_instr_field_list
ins_cache[$(pfield['id'])]#slurp
      #if ($pfield != $common_instr_field_list[-1])
, #slurp
      #end if
      #end for
      #end if
);
      #end if
    #else
    #* opens case statement *#
    case $(pinstr['id']): // Instruction $pinstr['name']
    #end if
      #* emits format behavior method call *#
      #for pformat in $format_ins_list
      #if ($pinstr['format'] == $pformat['name'])
      ISA._behavior_$(project_name)_$(pformat['name'])(#slurp
      #break
      #end if
      #end for
      #for pfield in $pformat['fields']
      #if ($ACDecCacheFlag)
instr_dec->F_$(pformat['name']).$(pfield['name'])#slurp
      #else
ins_cache[$(pfield['id'])]#slurp
      #end if
      #if ($pfield != $pformat['fields'][-1])
, #slurp
      #end if
      #end for
);
      #* emits instruction behavior method call *#
      ISA.behavior_$(pinstr['name'])(#slurp
      #for pfield in $pformat['fields']
      #if ($ACDecCacheFlag)
instr_dec->F_$(pformat['name']).$(pfield['name'])#slurp
      #else
ins_cache[$(pfield['id'])]#slurp
      #end if
      #if ($pfield != $pformat['fields'][-1])
, #slurp
      #end if
      #end for
);
      #if ($ACWaitFlag)
      ac_qk.inc(sc_time(module_period_ns*$(pinstr['cycles']), SC_NS));
      #end if
      #if ($ACThreading)
        goto *dispatch();

      #else
      break;
      #end if
    #end for

    #if not ($ACThreading)
  } // switch (ins_id

    #end if
  #if ($ACStatsFlag)
  if (!ac_wait_sig) {
      ISA.stats[$(project_name)_stat_ids::INSTRUCTIONS]++;
      (*(ISA.instr_stats[ins_id]))[$(project_name)_instr_stat_ids::COUNT]++;
  }

  #end if
  #if ($ACDebugFlag)
  if (ac_do_trace != 0)
      trace_file << hex << decode_pc << dec <<"\n";

  #end if
  #***** END EmitInstrExec ***#
  #else
  #********************************************#
  #* START EmitProcessorBhv                   *#
  #*!  Emits the body of a processor implementation for *#
  #* a processor without pipeline and with single cycle instruction. *#
  #* \brief Used by CreateProcessorImpl function *#
  #********************************************#
  for (;;) {
    #***************************************#
    #* START EmitFetchInit                 *#
    #*!  Emits the if statement executed   *#
    #*!  before fetches are performed.     *#
    #***************************************#
    #if ($ACPCAddress)
    #if not ($ACDecCacheFlag)
    if (bhv_pc >= APP_MEM->get_size()) {
    #else
    if (bhv_pc >= dec_cache_size) {
    #end if
      cerr << "ArchC: Address out of bounds (pc=0x" << hex << bhv_pc << ")." << endl;
      stop();
      #if ($ACThreading)
      longjmp(ac_env, AC_ACTION_STOP);
      #else
      return;
      #end if
    }
    #end if

    #*** END EmitFetchInit ***#
    #if ($ACABIFlag)
    #if ($ACSyscallJump)
    bool exec = true;
    if (ac_pc < 0x100) {
    #end if
      ##Emiting system calls handler.
      //!Handling System calls.
      switch (ac_pc) {
        \#define AC_SYSC(NAME,LOCATION) \
        case LOCATION: \
          #if ($ACStatsFlag)
          ISA.stats[$(project_name)_stat_ids::SYSCALLS]++; \
          #end if
          #if ($ACDebugFlag)
          if( ac_do_trace != 0 ) \
            trace_file << hex << ac_pc << dec << endl; \
          #end if
          ISA.syscall.NAME(); \
          #if ($ACSyscallJump)
          exec = false; \
          #end if
          break;
        \#include <ac_syscall.def>
        \#undef AC_SYSC

        #if ($ACSyscallJump)
      } // switch(ac_pc)
    } // if(ac_pc < 0x100)
    if (exec) {
        #else
        default:
        #end if
    #end if
          #if ($ACFullDecode)
          instr_dec = (DEC_CACHE + (ac_pc#slurp
          #if ($ACIndexFix)
/ $(largest_format_size/8)#slurp
          #end if
));
          ins_id = instr_dec->id;

          #else
          #********************************************#
          #* START EmitDecodification                 *#
          #*!  Emits the if statement that handles instruction decodification *#
          #* \brief Used by EmitProcessorBhv, EmitMultCycleProcessorBhv and CreateStgImpl functions *#
          #********************************************#
          #* #if ($HaveMemHier)
          #if ($fetchsize == $wordsize)
          *((ac_fetch*)(fetch)) = IM->read(ac_pc);
          #else if ($fetchsize == $wordsize/2)
          *((ac_fetch*)(fetch)) = IM->read_half(ac_pc);
          #else if ($fetchsize == 8)
          *((ac_fetch*)(fetch)) = IM->read_byte(ac_pc);
          #else
          <% print "ArchC ERROR: Fetchsize differs from wordsize or (wordsize/2) or 8: not implemented." %>
          #stop
          #end if

          #end if
          if(ac_wait_sig) {
            #if ($ACThreading)
            longjmp(ac_env, AC_ACTION_STOP);
            #else
            return;
            #end if
          }
          *#

          #if ($ACDecCacheFlag)
          instr_dec = (DEC_CACHE + (#slurp
          #if ($ACFullDecode)
decode_pc
          #else
ac_pc
          #end if
          #if ($ACIndexFix)
/ $(largest_format_size/8)#slurp
          #end if
));
          #if not ($ACFullDecode)
          if (!instr_dec->valid) {
          #end if
            unsigned* ins_cache;
          #end if
            #if not ($ACFullDecode)
            decode_pc = ac_pc;
            #end if
            quant = 0;
            ins_cache = (ISA.decoder)->Decode(reinterpret_cast<unsigned char*>(buffer), quant);

          #if ($ACDecCacheFlag)
          #if ($ACFullDecode)
          if( ins_cache ) {
          #else
          instr_dec->valid = true;
          #end if
            instr_dec->id = ins_cache ? ins_cache[IDENT]: 0;
            #if ($ACThreading)
            instr_dec->end_rot = IntRoutine[instr_dec->id];
            #end if
            #**********************************************#
            #* START EmitDecCacheAt                       *#
            #*!  Emits a Decoder Cache Attribution.       *#
            #* \brief Used by EmitDecodification function *#
            #**********************************************#
            switch (ISA.instr_format_table[instr_dec->id]) {
              #for pformat in $format_ins_list
              case $pformat['id']:
                #for pfield in $pformat['fields']
                instr_dec->F_$pformat['name'].$pformat['name'] = ins_cache[$pformat['id']];
                #end for
                break;
              #end for
              #if not ($ACFullDecode)
              default:
                cerr << "ArchC Error: Unidentified instruction. " << endl;
                cerr << "PC = " << hex << ac_pc << dec << endl;
                stop();
                #if ($ACThreading)
                longjmp(ac_env, AC_ACTION_STOP);
                #else
                return;
                #end if
              #end if
            }

            #* END EmitDecCacheAt *#
          }

          #if not ($ACFullDecode)
          ins_id = instr_dec->id;
          #end if
          #else
          ins_id = ins_cache ? ins_cache[IDENT]: 0;

          ##Checking if it is a valid instruction
          if(ins_id == 0) {
            cerr << "ArchC Error: Unidentified instruction. " << endl;
            cerr << "PC = " << hex << ac_pc << dec << endl;
            stop();
            #if ($ACThreading)
            longjmp(ac_env, AC_ACTION_STOP);
            #else
            return;
            #end if
          }
          #end if
          #*** END EmitDecodification ***#
          #end if

          #******************************************#
          #* START EmitInstrExec                    *#
          #*!  Emit code for executing instructions *#
          #* \brief Used by EmitProcessorBhv, EmitMultCycleProcessorBhv and CreateStgImpl functions *#
          #******************************************#
          #if ($ACThreading)
          I_Init:
            goto *dispatch();

          #if ($ACABIFlag and $ACDecCacheFlag)
          \#define AC_SYSC(NAME,LOCATION)
          Sys_\#\#LOCATION:
            #if ($ACStatsFlag)
            ISA.stats[$(project_name)_stat_ids::SYSCALLS]++;
            #end if
            #if ($ACDebugFlag)
            if (ac_do_trace != 0)
              trace_file << hex << ac_pc << dec << endl;
            #end if
            ISA.syscall.NAME();
            goto *dispatch();

          \#include <ac_syscall.def>
          \#undef AC_SYSC

          #end if
          #else
          #**********************************************************#
          #* START EmitInstrExecIni                                 *#
          #*!  Emit initial code for executing instructions         *#
          #* \brief Used by EmitInstrExec and EmitDispatch functions*#
          #**********************************************************#
          #if ($ACGDBIntegrationFlag)
          if (gdbstub && gdbstub->stop(ac_pc)) gdbstub->process_bp();

          #end if
          #if ($ACCurInstrID)
          ISA.cur_instr_id = ins_id;
          #end if
          #if not ($ACThreading and $ACABIFlag)
          ISA._behavior_instruction(#slurp
          #* common_instr_field_list has the list of fields for the generic instruction. *#
          #if ($ACDecCacheFlag)
          #for pfield in $common_instr_field_list
          #set $pformat = $format_ins_list[0]
instr_dec->F_$(pformat['name']).$(pfield['name'])#slurp
          #if ($pfield != $common_instr_field_list[-1])
, #slurp
          #end if
          #end for
          #else
          #for pfield in $common_instr_field_list
ins_cache[$(pfield['id'])]#slurp
          #if ($pfield != $common_instr_field_list[-1])
, #slurp
          #end if
          #end for
          #end if
);
          #end if

          #* END EmitInstrExecIni *#
          #* Switch statement for instruction selection *#
          switch (ins_id) {
          #end if
            #for pinstr in $instr_list
            #if ($ACThreading)
            I_$(pinstr['name']): // Instruction $(pinstr['name'])
              #if ($ACABIFlag)
              ISA._behavior_instruction(#slurp
              #* common_instr_field_list has the list of fields for the generic instruction. *#
              #if ($ACDecCacheFlag)
              #for pformat in $format_ins_list
              #if ($pinstr['format'] == $pformat['name'])
              #for pfield in $common_instr_field_list
instr_dec->F_$(pformat['name']).$(pfield['name'])#slurp
              #if ($pfield != $common_instr_field_list[-1])
, #slurp
              #end if
              #end for
              #break
              #end if
              #end for
              #else
              #for pfield in $common_instr_field_list
ins_cache[$(pfield['id'])]#slurp
              #if ($pfield != $common_instr_field_list[-1])
, #slurp
              #end if
              #end for
              #end if
);
              #end if
            #else
            #* opens case statement *#
            case $(pinstr['id']): // Instruction $pinstr['name']
            #end if
              #* emits format behavior method call *#
              #for pformat in $format_ins_list
              #if ($pinstr['format'] == $pformat['name'])
              ISA._behavior_$(project_name)_$(pformat['name'])(#slurp
              #break
              #end if
              #end for
              #for pfield in $pformat['fields']
              #if ($ACDecCacheFlag)
instr_dec->F_$(pformat['name']).$(pfield['name'])#slurp
              #else
ins_cache[$(pfield['id'])]#slurp
              #end if
              #if ($pfield != $pformat['fields'][-1])
, #slurp
              #end if
              #end for
);
              #* emits instruction behavior method call *#
              ISA.behavior_$(pinstr['name'])(#slurp
              #for pfield in $pformat['fields']
              #if ($ACDecCacheFlag)
instr_dec->F_$(pformat['name']).$(pfield['name'])#slurp
              #else
ins_cache[$(pfield['id'])]#slurp
              #end if
              #if ($pfield != $pformat['fields'][-1])
, #slurp
              #end if
              #end for
);

              #if ($ACWaitFlag)
              ac_qk.inc(sc_time(module_period_ns*$(pinstr['cycles']), SC_NS));

              #end if
              #if ($ACThreading)
                goto *dispatch();
              #else
              break;
              #end if
            #end for

            #if not ($ACThreading)
          } // switch (ins_id)

            #end if
          #if ($ACStatsFlag)
          if (!ac_wait_sig) {
              ISA.stats[$(project_name)_stat_ids::INSTRUCTIONS]++;
              (*(ISA.instr_stats[ins_id]))[$(project_name)_instr_stat_ids::COUNT]++;
          }

          #end if
          #if ($ACDebugFlag)
          if (ac_do_trace != 0)
              trace_file << hex << decode_pc << dec <<"\n";

          #end if
          #***** END EmitInstrExec ***#
          #if ($ACABIFlag)
          #if ($ACSyscallJump)
        } // if (exec)
          #else
          break;
        } // switch(ac_pc)
          #end if

          #end if
        ac_instr_counter++;
        #if ($ACVerboseFlag)
        #if ($ACABIFlag)
        done.write(1);
        #else
        bhv_done.write(1);
        #end if

        #end if
        ##!Emit update method.
        #******************************************#
        #* START EmitUpdateMethod                 *#
        #*!  Emits a method to update pipe regs   *#
        #* \brief Used by CreateArchImpl function *#
        #******************************************#
        ##Emiting Update Method.
        #if ($ACDelayFlag or $HaveMemHier or $ACWaitFlag)
        //!Updating Regs for behavioral simulation.
        #end if
        #if not ($ACLongJmpStop)
        if (ac_stop_flag)
        #if ($ACThreading)
          longjmp(ac_env, AC_ACTION_STOP);
        #else
          return;
        #end if

        #end if
        #if ($ACDelayFlag)
        if (!ac_wait_sig) {
          #for pstorage in $storage_list
          $(pstorage['name']).commit_delays((double)ac_cycle_counter);
          #end for
          ac_pc.commit_delays((double)ac_cycle_counter);
          if (!ac_parallel_sig)
              ac_cycle_counter ++;
          else
              ac_parallel_sig = 0;
        }

        #end if
        #*
        #if ($HaveMemHier)
        #for pstorage in $storage_list
        #if ($pstorage['type'] == "CACHE" or $pstorage['type'] == "ICACHE" or $pstorage['type'] == "DCACHE" or $pstorage['type'] == "MEM")
        $(pstorage['name']).process_request( );
        #end if
        #end for

        #end if *#
        #if ($ACWaitFlag)
        if (ac_qk.need_sync()) {
          ac_qk.sync();
        }

        #end if
        #** END EmitUpdateMethod **#
  } // for (;;)
  #* END EmitProcessorBhv *#
  #end if
} // behavior()

##Emiting Verification Method.
#if ($ACVerboseFlag)
//!Verification method.
void $(project_name)::ac_verify() {
  for (;;) {

    if (done.read()) {
      \#ifdef AC_VERBOSE
      #for pstorage in $storage_list
      $(pstorage['name']).change_dump(cerr);
      #end for
      \#endif

      \#ifdef AC_UPDATE_LOG
      #for pstorage in $storage_list
      $(pstorage['name']).reset_log();
      #end for
      \#endif

      done.write(0);
    }
    wait();
  }
}
#end if

#* SIGNAL HANDLERS *#
\#include <ac_sighandlers.H>

#* init() and stop() *#
#* init() with no parameters *#
void $(project_name)::init() {
  #*CACHE*#
  #for pstorage in $storage_list
  #if ($pstorage['type'] == "CACHE" or $pstorage['type'] == "ICACHE" or $pstorage['type'] == "DCACHE")
  if (ac_cache_traces.find("$(pstorage['name'])") != ac_cache_traces.end())
    $(pstorage['name']).set_trace(*ac_cache_traces["$(pstorage['name'])"]);
  #end if
  #end for

  set_args(ac_argc, ac_argv);
  \#ifdef AC_VERIFY
  set_queue(av[0]);
  \#endif

  ac_pc = ac_start_addr;
  ISA._behavior_begin();
  cerr << "ArchC: -------------------- Starting Simulation --------------------" << endl;
  InitStat();

  signal(SIGINT, sigint_handler);
  signal(SIGTERM, sigint_handler);
  signal(SIGSEGV, sigsegv_handler);
  signal(SIGUSR1, sigusr1_handler);

  \#ifdef USE_GDB
  signal(SIGUSR2, sigusr2_handler);
  \#endif

  \#ifndef AC_COMPSIM
  set_running();
  \#else
  void Execute(int argc, char *argv[]);
  Execute(argc, argv);
  \#endif
}

#* init() with 3 parameters *#
void $(project_name)::init(int ac, char *av[]) {
  extern char* appfilename;
  ac_init_opt(ac, av);
  ac_init_app(ac, av);
  APP_MEM->load(appfilename);

  #for pstorage in $storage_list
  #if ($pstorage['type'] == "CACHE" or $pstorage['type'] == "ICACHE" or $pstorage['type'] == "DCACHE")
  if (ac_cache_traces.find("$(pstorage['name'])") != ac_cache_traces.end())
    $(pstorage['name']).set_trace(*ac_cache_traces["$(pstorage['name'])"]);
  #end if
  #end for

  set_args(ac_argc, ac_argv);
  \#ifdef AC_VERIFY
  set_queue(av[0]);
  \#endif

  ac_pc = ac_start_addr;
  ISA._behavior_begin();
  cerr << "ArchC: -------------------- Starting Simulation --------------------" << endl;
  InitStat();

  signal(SIGINT, sigint_handler);
  signal(SIGTERM, sigint_handler);
  signal(SIGSEGV, sigsegv_handler);
  signal(SIGUSR1, sigusr1_handler);
  \#ifdef USE_GDB
  signal(SIGUSR2, sigusr2_handler);
  \#endif

  \#ifndef AC_COMPSIM
  set_running();
  \#else
  void Execute(int argc, char *argv[]);
  Execute(argc, argv);
  \#endif
}

#* stop() *#
//Stop simulation (may receive exit status)
void $(project_name)::stop(int status) {
  cerr << "ArchC: -------------------- Simulation Finished --------------------" << endl;
  ISA._behavior_end();
  ac_stop_flag = 1;
  ac_exit_status = status;
  \#ifndef AC_COMPSIM
  set_stopped();
  \#endif
  #if ($ACLongJmpStop)
  longjmp(ac_env, AC_ACTION_STOP);
  #end if
}

#* Program loading functions *#
#* load() *#
void $(project_name)::load(char* program) {
  APP_MEM->load(program);
}

#* delayed_load() *#
void $(project_name)::delayed_load(char* program) {
  has_delayed_load = true;
  delayed_load_program = new char[strlen(program)];
  strcpy(delayed_load_program, program);
}

#* Some simple GDB support methods *#
#if ($ACGDBIntegrationFlag)
#* get_gdbstub() *#
// Returns pointer to gdbstub
AC_GDB<$(project_name)_parms::ac_word>* $(project_name)::get_gdbstub() {
  return gdbstub;
}

#* get_ac_tgt_endian() *#
// Returns true if model endianness doesn't match with host's, false otherwise
bool $(project_name)::get_ac_tgt_endian() {
  return ac_tgt_endian;
}

#* ac_stop() *#
// Stops the processor
void $(project_name)::ac_stop() {
  stop();
}

#end if
#* get_ac_pc() *#
// Returns ac_pc value
unsigned $(project_name)::get_ac_pc() {
  return ac_pc;
}

#* set_ac_pc() *#
// Assigns value to ac_pc
void $(project_name)::set_ac_pc(unsigned int value) {
  ac_pc = value;
}

#* PrintStat() *#
// Wrapper function to PrintStat().
void $(project_name)::PrintStat() {
  ac_arch<$(project_name)_parms::ac_word, $(project_name)_parms::ac_Hword>::PrintStat();
  #if ($HaveMemHier)

  #for pstorage in $storage_list
  #if ($pstorage['type'] == "CACHE" or $pstorage['type'] == "ICACHE" or $pstorage['type'] == "DCACHE")
  std::cerr << "cache: $(pstorage['name'])\n";
  $(pstorage['name']).print_statistics(std::cerr);
  #end if
  #end for
  #end if
}

#* GDB enable method *#
#if ($ACGDBIntegrationFlag)
// Enables GDB
void $(project_name)::enable_gdb(int port) {
  gdbstub->set_port(port);
  gdbstub->enable();
  gdbstub->connect();
}
#end if

##!END OF FILE.