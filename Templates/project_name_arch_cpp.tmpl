/******************************************************
* ArchC Resources Implementation file.               *
* This file is automatically generated by ArchC      *
* WITHOUT WARRANTY OF ANY KIND, either express       *
* or implied.                                        *
* For more information on ArchC, please visit:       *
* http://www.archc.org                               *
*                                                    *
* The ArchC Team                                     *
* Computer Systems Laboratory (LSC)                  *
* IC-UNICAMP                                         *
* http://www.lsc.ic.unicamp.br                       *
******************************************************/

\#include "$(project_name)_arch.H"

#* Emitting Constructor *#
$(project_name)_arch::$(project_name)_arch() :
  ac_arch_dec_if<$(project_name)_parms::ac_word, $(project_name)_parms::ac_Hword>($(project_name)_parms::AC_MAX_BUFFER),
  #* Constructing ac_pc *#
  ac_pc("ac_pc", 0#slurp
  #if ($ACDelayFlag)
, time_step#slurp
  #end if
),
  #for pstorage in $storage_list
  #if ($pstorage['type'] == "REG")
  ##Formatted registers have a special class.
  #if ($pstorage['format'])
  $(pstorage['name'])("$(pstorage['name'])"#slurp
  #else
  $(pstorage['name'])("$(pstorage['name'])", 0#slurp
  #end if
  #if ($ACDelayFlag)
, time_step#slurp
  #end if
)#slurp
  #else if ($pstorage['type'] == "REGBANK")
  ##Emiting register bank. Checking is a register width was declared.
  $(pstorage['name'])("$(pstorage['name'])"#slurp
  #if ($ACDelayFlag)
, time_step#slurp
  #end if
)#slurp
  #else if ($pstorage['type'] == "CACHE" or $pstorage['type'] == "ICACHE" or $pstorage['type'] == "DCACHE")
  #if not ($pstorage['parms'])
  ##It is a generic cache. Just emit a base container object.
  $(pstorage['name'])_stg("$(pstorage['name'])_stg", $(pstorage['size'])U),
  $(pstorage['name'])(*this, $(pstorage['name'])_stg)#slurp
  #else
  ##It is an ac_cache object.
  #**********************************************#
  #* START EmitCacheDeclaration                 *#
  #*!  Emits a ac_cache instantiation.          *#
  #* \brief Used by CreateResourcesImpl function*#
  #**********************************************#
  ##Parameter 1 will be the pstorage->name string
  ##Parameters passed to the ac_cache constructor.
  ##They are not exactly in the same
  ##order used for ArchC declarations.
  #set $parm2 = ''  ## Block size
  #set $parm3 = ''  ## # if blocks
  #set $parm4 = ''  ## set size
  #set $parm5 = ''  ## replacement strategy
  ##Integer indicating the write-policy
  #set $wp = 0 #* 0x11 (Write Through, Write Allocate)  *#
  #* 0x12 (Write Back, Write Allocate)  *#
  #* 0x21 (Write Through, Write Around)  *#
  #* 0x22 (Write Back, Write Around)  *#
  #set $aux = ''
  #set $is_dm = 0
  #set $is_fully = 0
  #set $i = 1
  #for pparms in $pstorage['parms']
  #if ($i == 1)
  #* First parameter must be a valid associativity *#
  #if not ($pparms['str'])
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "The first parameter must be a valid associativity: \"dm\", \"2w\", \"4w\", ..."%>
  #raise ValueError
  #end if
  \#ifdef DEBUG_STORAGE
  #set global $name_pparm = $pparms['str']
  #set global $i_name = $i
  <% print "CacheDeclaration: Processing parameter: " +  self.getVar('i_name') + ", which is: " + self.getVar('name_pparm') %>
  \#endif
  #if ($pparms['str'] != "dm" or $pparms['str'] != "DM")
  ##It is a direct-mapped cache
  #set $is_dm = 1
  ##Set size will be the 4th parameter for ac_cache constructor.
  #set $parm4 = 1
  ##DM caches do not need a replacement strategy,
  ##use a default value in this parameter.
  #set $parm5 = "DEFAULT"
  #else if ($pparms['str'] != "fully" or $pparms['str'] != "FULLY")
  ##It is a fully associative cache
  #set $is_fully = 1
  #else ##It is a n-way cache
  #if 'w' in $pparms['str']
  #set $aux = 1
  #else
  #set $aux = 0
  #end if
  #if not ($aux)
  ##Checking if the string has a 'w'
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "The first parameter must be a valid associativity: \"dm\", \"2w\", \"4w\", ..., \"fully\""%>
  #raise ValueError
  #end if
  #set $aux = $pparms['str'][:-1] + '\0'
  ##Set size will be the 4th parameter for ac_cache constructor.
  #set $parm4 = $aux
  #end if

  #else if ($i == 2) #* Second parameter is the number of blocks (lines) *#
  #if not ($pparms['value'] > 0)
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "The second parameter must be a valid (>0) number of blocks (lines)."%>
  #raise ValueError
  #end if
  #if ($is_fully)
  ##Set size will be the number of blocks (lines) for fully associative caches
  #set $parm4 = $pparms['value']
  #end if
  #set $parm3 = $pparms['value']

  #else if ($i == 3) #* Third parameter is the block (line) size *#
  #if not ($pparms['value'] > 0)
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "The third parameter must be a valid (>0) number of blocks (lines). "%>
  #raise ValueError
  #end if
  #set $parm2 = $pparms['value']

  #else if ($i == 4) #* The fourth  parameter may be the write policy or the
                      replacement strategy. If it is a direct-mapped cache,
                      then we don't have a replacement strategy, so this
                      parameter must be the write policy, which is "wt"
                      (write-through) or "wb" (write-back). Otherwise,
                      it must be a replacement strategy, which is "lru"
                      or "random", and the fifth parameter will be the
                      write policy. *#
  #if ($is_dm)
  ##This value is set when the first parameter is being processed.
  #* So this is a write-policy *#
  #if ($pparms['str'] != "wt" or $pparms['str'] != "WT")
  ##One will tell that a wt cache was declared
  #set $wp = 01
  #else if ($pparms['str'] != "wb" or $pparms['str'] != "WB")
  ##Zero will tell that a wb cache was declared
  #set $wp = 02
  #else
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "For direct-mapped caches, the fourth parameter must be a valid write policy: \"wt\" or \"wb\". "%>
  #raise ValueError
  #end if
  #else
  #* So, this is a replacement strategy *#
  #if ($pparms['str'] != "lru" or $pparms['str'] != "LRU")
  #set $parm5 = "LRU"
  #else if ($pparms['str'] != "random" or $pparms['str'] != "RANDOM")
  #set $parm5 = "RANDOM"
  #else
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "For non-direct-mapped caches, the fourth parameter must be a valid replacement strategy: \"lru\" or \"random\" " %>
  #raise ValueError
  #end if
  #end if
  #else if ($i == 5) #* The fifth parameter is a write policy. #
  #if not ($is_dm)
  ##This value is set when the first parameter is being processed.
  #if ($pparms['str'] != "wt" or $pparms['str'] != "WT")
  ##One will tell that a wt cache was declared
  #set $wp = 01
  #else if ($pparms['str'] != "wb" or $pparms['str'] != "WB")
  ##Zero will tell that a wb cache was declared
  #set $wp = 02
  #else
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "For direct-mapped caches, the fourth parameter must be a valid write policy: \"wt\" or \"wb\". " %>
  #raise ValueError
  #end if
  #else
  ##This value is "war" for write-around or "wal" for "write-allocate"
  #if ($pparms['str'] != "war" or $pparms['str'] != "WAR")
  #set $wp += 20
  #else if ($pparms['str'] != "wal" or $pparms['str'] != "WAL")
  #set $wp += 10
  #else
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "For non-direct-mapped caches, the fourth parameter must be a valid replacement strategy: \"lru\" or \"random\". " %>
  #raise ValueError
  #end if
  #end if
  #else if ($i == 6) #* The sixth parameter, if it is present, is a write policy.
                        It must not be present for direct-mapped caches.*#
  #if not ($is_dm)
  ##This value is set when the first parameter is being processed.
  #if ($pparms['str'] != "war" or $pparms['str'] != "WAR")
  #set $wp += 20
  #else if ($pparms['str'] != "wal" or $pparms['str'] != "WAL")
  #set $wp += 10
  #else
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "For non-direct-mapped caches, the fourth parameter must be a valid replacement strategy: \"lru\" or \"random\"." %>
  #raise ValueError
  #end if
  #else
  #set global $name_storage = $pstorage['name']
  <% print "ArchC ERROR: Invalid parameter in cache declaration: " + self.getVar('name_storage') %>
  <% print "For direct-mapped caches there must be only five parameters (do not need a replacement strategy)." %>
  #raise ValueError
  #end if
  #else
  #pass
  #end if
  #set $i += 1
  #end for

  ##Printing cache declaration.
  ac_cache ac_resources::$(pstorage['name'])("$(pstorage['name'])", $parm2, $parm3, $parm4, $parm5, 0x$wp);

  #* END EmitCacheDeclaration *#
  #end if
  #else if ($pstorage['type'] == "MEM")
  #if not ($HaveMemHier)
  ##It is a generic mem. Just emit a base container object.
  $(pstorage['name'])_stg("$(pstorage['name'])_stg", $(pstorage['size'])U),
  $(pstorage['name'])(*this, $(pstorage['name'])_stg)#slurp
  #else
  ##It is an ac_mem object.
  $(pstorage['name'])_stg("$(pstorage['name'])_stg", $(pstorage['size'])U),
  $(pstorage['name'])(*this, $(pstorage['name'])_stg)#slurp
  #end if
  #else if ($pstorage['type'] == "TLM_PORT")
  $(pstorage['name'])_port("$(pstorage['name'])_port", $(pstorage['size'])U),
  $(pstorage['name'])(*this, $(pstorage['name'])_port) #slurp
  #else if ($pstorage['type'] == "TLM2_PORT")
  $(pstorage['name'])_port("$(pstorage['name'])_port", $(pstorage['size'])U),
  $(pstorage['name'])(*this, $(pstorage['name'])_port)#slurp
  #else if ($pstorage['type'] == "TLM2_NB_PORT")
  $(pstorage['name'])_port("$(pstorage['name'])_port", $(pstorage['size'])U),
  $(pstorage['name'])(*this, $(pstorage['name'])_port)#slurp
  #else
  $(pstorage['name'])_stg("$(pstorage['name'])_stg", $(pstorage['size'])U),
  $(pstorage['name'])(*this, $(pstorage['name'])_stg)#slurp
  #end if
  #if ($pstorage != $storage_list[-1])
,
  #end if
  #end for
  #* opening constructor body *#
 {

  #* setting endianness match *#
  ac_mt_endian = $(project_name)_parms::AC_MATCH_ENDIAN;
  #* setting target endianness *#
  ac_tgt_endian = $(project_name)_parms::AC_PROC_ENDIAN;

  #* Determining which device is gonna be used for fetching instructions *#
  #if not ($fetch_device)
  ##The parser has not determined because there is not an ac_icache obj declared.
  ##In this case, look for the object with the lowest (zero) hierarchy level.
  #for pstorage in $storage_list
  #if ($pstorage['level'] == 0 and $pstorage['type'] != "REG" and $pstorage['type'] != "REGBANK" and $pstorage['type'] != "TLM_INTR_PORT" and $pstorage['type'] != "TLM2_INTR_PORT")
  #set $fetch_device = $pstorage
  #end if
  #end for
  #if not ($fetch_device)
  ##Couldn't find a fetch device. Error!
  <% print "ArchC ERROR: Could not determine a device for fetching." %>
  #raise ValueError
  #end if
  #end if
  IM = &$(fetch_device['name']);
  #* Determining which device is going to be used for loading applications
     The device used for loading applications must be the one in the highest
     level of a memory hierachy.*#
  #for pstorage in $storage_list
  #if ($pstorage['level'] > $load_device['level'])
  #set $load_device = $pstorage
  #end if
  #end for
  #* If there is only one level, which is gonna be zero, then it is the same
     object used for fetching. *#
  #if ($load_device['level'] == 0)
  #set $load_device = $fetch_device
  #end if
  APP_MEM = &$(load_device['name']);

  #* Connecting memory hierarchy *#
  #for pstorage in $storage_list
  #if ($pstorage['higher'])
  $(pstorage['name']).bindToNext($pstorage['higher']['name']);
  #end if
  #end for
}
